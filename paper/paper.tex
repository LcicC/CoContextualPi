\documentclass[sigplan,screen,review]{acmart}

\usepackage{todonotes}

\newcommand{\picalc}{$\pi$-calculus}
\newcommand{\Picalc}{$\pi$-Calculus}


\title{Extended Abstract}
\subtitle{Co-Contextual Type Inference for the Linear \Picalc{} in Agda}

\author{Uma Zalakain}
\affiliation{University of Glasgow}
\email{u.zalakain.1@research.gla.ac.uk}

\author{Ornela Dardha}
\affiliation{University of Glasgow}
\email{ornela.dardha@glasgow.ac.uk}

\begin{document}

\begin{abstract}
  The linear \picalc{} is a well-known substructural type system for the \picalc{}:
  it is a common target for the encoding of session-typed languages \todo{cite},
  and it in direct correspondence with classical linear logic \todo{cite}.

  Type inference for the linear \picalc{} comes with its own challenges:
  for one, processes themselves are untyped, and thus typing constraints only apply to the typing contexts;
  moreover, typing constraints on usage annotations \emph{cannot always be eagerly solved in open processes}.

  We approach the first challenge using \emph{co-contextual type inference} \cite{ErdwegBKKM15}, where processes are traversed bottom-up and constraints are collected (and when possible eagerly solved) and merged on context splits.
  We approach the latter challenge by allowing the resolution of some of the constraints to be deferred.
  We state soundness and completeness theorems that take this deferral of constraint resolution into account.
  We state a progress (?) theorem that shows that only those constraints that need to be deferred are deferred.
  \todo{be more precise}
  We are working on mechanising our work in Agda.
\end{abstract}


\maketitle

\section{Introduction}\label{introduction}

We define an untyped but well scoped \picalc{} using type-level de Bruijn \todo{cite} indices \autoref{syntax}.
We define a small expression language within the process syntax to handle composite sum and product types.
On top of the well-scoped syntax we provide the standard linear type-system using context-splits \autoref{type-system}.
The type system is indexed by a typing context that admits unsolved metavariables.
These unsolved metavariables are however well kinded: either types or usage annotations.

\todo{insert example showing why we need deferral}

We split typing inference into constraint collection and constraint solving \autoref{inference}.
We start by defining constraints on types and usage annotations \autoref{constraints}
We collect constraints bottom-up, creating extra \emph{merging} constraints on context splits.
This allows type-inference to be easily parallelisable.
We postulate soundness and completeness theorems that allow for constraint solving to be deferred \autoref{inference-theorems}.


\textbf{TODO: recursion/replication} \textbf{TODO: bounded linear
types?} \textbf{TODO: type assertions}

Consider a \(\pi\)-calculus with usage annotations on channels. These
usage annotations are one of \(0\), \(1\), or \(\omega\). \(0\) must not
be used, \(1\) must be used exactly once, \(\omega\) can be used as many
times as desired. Sum and products contain usage annotations on their
leafs.

\section{Type System}\label{type-system}


\subsection{Types}\label{types}

Let \(\gamma\) be a context of metavariable kinds, where a kind is
either a \texttt{type} or a \texttt{usage}. Then \(\gamma \ni k\) is a
choice of a \(k\) inside \(\gamma\). \[
\begin{aligned}
S, T : \texttt{Type}~\gamma &= \texttt{mvar}~(\gamma \ni \texttt{type}) ~|~ \#_{i,o}t ~|~ \top ~|~ S + T ~|~ S \times T \\
i,o : \texttt{Usage}~\gamma &= \texttt{mvar}~(\gamma \ni \texttt{usage}) ~|~ 0\cdot ~|~ 1\cdot ~|~ \omega\cdot
\end{aligned}
\]

The type system is the usual standard type system based on context
splits that one defines for the pi calculus. TODO: insert type system
definition here:.

Usage annotations are \(0\cdot\), \(1\cdot\), \(\omega\cdot\). Context
splits are defined as follows:

\[
\begin{aligned}
\forall x.    && x           &= x + 0\cdot \\
\forall x.    && x           &= 0\cdot + x \\
\forall x ~y. && \omega\cdot &= y + z
\end{aligned}
\]

Only the usage annotations at the upper level of a channel type are
split: the usage annotations of any channel type that is send as data
are preserved on all three sides of the split.

\hypertarget{inference}{%
\section{Inference}\label{inference}}

Co-contextual type inference: traverses the syntax bottom up, collecting
constraints on the typing context.

Constraints can be of the following form:

\begin{itemize}
\item
  \(S = T\): types \(S\) and \(T\) must be unifiable.
\item
  \(S = T + R\): adding up the usage annotations in \(T\) and \(R\) must
  result in \(S\).
\end{itemize}

Constraints of the form \(S = T\) can always be eagerly unified. However
constraints of the form \(S = T + R\) might contain variables:
\(\texttt{mvar}~x = \texttt{mvar}~y + \texttt{mvar}~z\). In an open
process, these variables cannot safely be instantiated to \(0\). As
such, no substitution is possible, yet we need to remember the
constraint. (It might also be that some constraints have more than one
possible solution.) At the same time, we need to show that the
constraints that we postulate are enough to solve the problem.

\paragraph{Constraint Satisfaction}

The \([\![\_]\!]\) function interprets constraints into their type
counterparts \(S \equiv T\) and \(S = T + R\). Substituting into a
constraint substitutes pointwise.

\paragraph{Inference}

\[
\texttt{infer} : \forall (p : \texttt{Proc}~n). ~ \exists \gamma. ~ \texttt{Ctx}~n~\gamma \times \texttt{List}~(\texttt{Constr}~\gamma)
\]

\paragraph{Inference soundness.}

Every substitution \(\sigma\) that makes the constraints hold will make
the process typable under the substituted context. \[
\begin{aligned}
\texttt{infer-sound} &: \forall (p : \texttt{Proc}~n). ~ \texttt{infer}~P \equiv \gamma , \Gamma , cs \\
&\to \forall (\sigma : \texttt{Subst}~\gamma~\delta). ~ [\![ \sigma \triangleleft cs ]\!] \\
&\to (\sigma \triangleleft \Gamma) \vdash P
\end{aligned}
\]

\paragraph{Inference completeness.}

For every context \(\Delta\) that makes the process typable there exists
a most general substitution \(\sigma\) that will solve the constraints
and which substitutes in \(\Gamma\) to something more general than
\(\Delta\). \[
\begin{aligned}
\texttt{infer-complete} &: \forall (p : \texttt{Proc}~n). ~ \texttt{infer}~P \equiv \gamma , \Gamma , cs \\
&\to \forall (\Delta : \texttt{Ctx}~n~\gamma). ~ \Delta \vdash P \\
&\to \exists \delta. ~ \exists (\sigma : \texttt{Subst}~\gamma~\delta). \\
&\to [\![ \sigma \triangleleft cs ]\!] \times \Delta \subseteq (\sigma \triangleleft \Gamma)
\end{aligned}
\] where \[
\Delta \subseteq \Gamma \triangleq \exists \delta. ~ \exists (\sigma : \texttt{Subst} \_ \delta). ~ \Delta \equiv (\sigma \triangleleft \Gamma)
\]

\hypertarget{constraint-resolution}{%
\section{Constraint Resolution}\label{constraint-resolution}}

\paragraph{Constraint Resolution.}

Given a set of accumulated substitutions and some constraints, we will
return (hopefully) some further substitutions, and a set of leftover
constraints to which the substitutions have been applied. These leftover
constraints can either not be simplified or are unsatisfiable. \[
\begin{aligned}
\texttt{solve} &: \texttt{Subst}~\gamma~\delta \times \texttt{List}~(\texttt{Constr}~\delta) \\
&\to \texttt{Subst}~\gamma~\phi \times \texttt{List}~(\texttt{Constr}~\phi)
\end{aligned}
\]

\paragraph{Soundness.}

The simplified constraints are enough to entail the original
constraints. \[
\begin{aligned}
\texttt{solve-sound}
&: \texttt{solve}~(\sigma_1, cs_1) \equiv (\sigma_2, cs_2) \\
&\to \forall (\sigma_f : \texttt{Subst}~\gamma~\delta) \\
& \to [\![ \sigma_f \triangleleft cs_2 ]\!] \to [\![ \sigma_f \cdot \sigma_2 \triangleleft cs_1 ]\!]
\end{aligned}
\]

\paragraph{Completeness.}

Any substitution \(\sigma_f\) that makes the original constraints
\(cs_1\) hold will be a specialisation \(\sigma_f\) of our returned
substitution \(\sigma_2\). The specialisation \(\sigma_g\) will make the
returned constraints \(cs_2\) hold. \[
\begin{aligned}
\texttt{solve-sound}
&: \texttt{solve}~(\sigma_1, cs_1) \equiv (\sigma_2, cs_2) \\
&\to \forall (\sigma_f : \texttt{Subst}~\gamma~\delta). ~ [\![ \sigma_f \triangleleft cs_1 ]\!] \\
&\to \exists (\sigma_g : \sigma_f = \sigma_g \cdot \sigma_2) \times [\![ \sigma_g \triangleleft cs_2 ]\!]
\end{aligned}
\]

\paragraph{Progress.}

Nothing prevents us from returning the original constraints as output.
We therefore promise that every constraint we return is either currently
unsolvable because we have not enough information, or is unsatisfiable
altogether. \[
\begin{aligned}
\texttt{solve-sound}
&: \texttt{solve}~(\sigma_1, cs_1) \equiv (\sigma_2, cs_2) \\
&\to \forall c \in cs_2. ~ \texttt{IsDeferred}~c \uplus \texttt{IsUnsat}~c
\end{aligned}
\] where \[
\texttt{IsUnsat}~c = \forall \sigma. ~ \neg [\![ \sigma \triangleleft c ]\!]
\]

\paragraph{Instantiation.}

\[
\forall c. ~ \texttt{IsDeferred}~c \to \exists \sigma. [\![ \sigma \triangleleft c ]\!]
\]

\bibliographystyle{abbrvnat}
\bibliography{paper}
\end{document}